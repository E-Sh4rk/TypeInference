\documentclass[a4paper]{article}

\usepackage{setup}

\hypersetup{pdfstartview=XYZ}%         zoom par defaut

\setlength{\droptitle}{-5em}   % This is your set screw
\title{\vspace{1.5cm}Type inference - M2 Internship}
\author{Mickael LAURENT}
\date{\vspace{-5ex}}

\pagenumbering{gobble}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{corollary}{Corollary}

\begin{document}

  \maketitle

  We define $\tyof e \Gamma$ as follows:
  \begin{align*}
    \tyof e \Gamma = 
    \left\{\begin{array}{ll}
      \ts & \text{if } \Gamma \vdash e:\ts \\
      \tsempty & \text{otherwise}
    \end{array}\right.
  \end{align*}

  \section{Definitions}

    \begin{definition}[Bottom environment]
      Let $\Gamma$ an environment.\\
      $\Gamma$ is bottom (noted $\Gamma = \bot$) iff $\exists e\in\dom\Gamma.\ \Gamma(e)\simeq\Empty$.
    \end{definition}

    \begin{definition}[(Pre)order on environments]
    Let $\Gamma$ and $\Gamma'$ two environments. We say that $\Gamma' \leq \Gamma$ iff:
    \begin{align*}
        &\Gamma'=\bot \text{ or } (\Gamma\neq\bot \text{ and } \forall e \in \dom \Gamma.\ \tyof e \Gamma \leq \Gamma(e))
    \end{align*}
    \end{definition}

    \begin{definition}[Plinth]
      A plinth $S$ is a set of types such that:
      \begin{itemize}
        \item $S$ is finite.
        \item $\Empty \in S$ and $S$ is stable by $\neg, \land, \vee$. 
        \item If $\tau$ is a DNF of $t\in S$, let's introduce $A=\{t_a \alt \exists (P,N) \in \tau \text{ s.t. } t_a \in P \text{ or } t_a \in N \}$. Thus:
        \begin{itemize}
          \item For all $t_a \in A$, we have $t_a \in S$.
          \item For all $t_1$, $t_2$ such that $\arrow {t_1} {t_2} \in A$ or $\pair {t_1} {t_2} \in A$,
          we have $t_1 \in S$ and $t_2 \in S$.
        \end{itemize}
      \end{itemize}
    \end{definition}

    %\begin{definition}[Structure of types]
    %  A structure is a tree defined by the following grammar:
    %  \[
    %    \begin{array}{lrcl}
    %    \textbf{Structure} & s & ::= & [] \alt \pair s s \alt \arrow s s\\
    %    \end{array}
    %  \]
    %
    %  A type $t$ is compatible with a structure $s$ if there exists a vector of types $\vec t$
    %  such that $t = s[\vec t]$ with $s[\vec t]$ refering to the structure $s$ where every hole is replaced
    %  by the associated type in $\vec t$ (the i-th hole is replaced by the i-th component of $\vec t$).
    %
    %  A type $t$ is generated by a set of structures $S$ and a set of types $T$ if $t$ can be written
    %  $t=\bigvee_{i\in I}\left(\bigwedge_{p\in P_i}t_p \land \bigwedge_{n\in N_i}t'_n \right)$ with $I$ finite, all $P_i$ and $N_i$ finite,
    %  and such that for any $t_p$ and $t'_n$, there is $s\in S$ and $\vec t$ a vector of elements of $T$ such that $t_{i,j}=s[\vec t]$.
    %\end{definition}

    \begin{definition}[n-generated types]
      A structure is a tree defined by the following grammar:
      \[
        \begin{array}{lrcl}
        \textbf{Structure} & s & ::= & [] \alt \pair s s \alt \arrow s s \alt \neg s\\
        \end{array}
      \]
      
      A structure has depth $n$ if the associated tree has depth $n$, without counting the $\neg$ nodes and the leaves.

      For a structure $s$ and a vector of types $\vec t$, we denote by $s[\vec t]$ the type obtained by replacing every
      hole (=leaf) of $s$ by the associated type in $\vec t$ (the i-th hole of $s$ is replaced by the i-th component of $\vec t$).

      A type $t$ is n-generated by a set of types $T$ if $t$ can be written
      $t=\bigvee_{i\in I}\left(\bigwedge_{j\in J_i}t_j\right)$ with $I$ and all $J_i$ finites,
      and such that all $t_j$ can be written $t_j = s[\vec t]$ with $s$ a structure of depth at most $n$
      and $\vec t$ a vector of elements of $T$.
    \end{definition}

  \section{Theorems}

  \begin{lemma}[Monotonicity and well-definedness of $\Refine p {e,t} \Gamma$]
    \begin{align*}
      &\forall e,\Gamma,\Gamma'.\ \Gamma'\leq\Gamma \Rightarrow \tyof e {\Gamma'} \leq \tyof e {\Gamma}\\
      &\forall e,\Gamma.\ \tyof e \Gamma \neq \tsempty \Rightarrow \Refine p {e,t} \Gamma \text{ is well-defined}\\
      &\forall e,\Gamma,\Gamma'.\ \Gamma'\leq\Gamma \text{ and } \tyof e \Gamma \neq \tsempty \Rightarrow \Refine p {e,t} {\Gamma'} \leq \Refine p {e,t} \Gamma\\
    \end{align*}
  Moreover, the greatest fixpoint $\fixpoint_\Gamma (\RefineStep p {e,t})$ can be computed by iterating
  the application of $\RefineStep p {e,t}$ starting from $\gamma$, until a fixed point is reached.
  The termination will be proved later.
  \end{lemma}

  \begin{lemma}
    Every finite set of types is included in a plinth.
  \end{lemma}
  Proof: Alain Frisch thesis, theorem 3.8 (p64) [TODO: ref].

  \begin{theorem}[$\texttt{Refine}$ computation]
    The fixpoint $\fixpoint_\Gamma (\RefineStep p {e,t})$ can be reached in a finite number of iterations.
  \end{theorem}

  \begin{theorem}[Soundness of the algorithm]
    \begin{align*}
      &\forall \Gamma, e, t.\ t\in\tyof e \Gamma \Rightarrow \Gamma \vdash e:t\text{ is derivable}\\
      &\forall \Gamma, \Gamma', p, e, t.\ \Refine p {e,t} \Gamma = \Gamma' \Rightarrow \Gamma \evdash p e t \Gamma' \text{ is derivable}\\
      &\forall \Gamma, p, e, t, t', \varpi.\ \Gp p {\Gamma,e,t} (\varpi) = t' \Rightarrow \pvdash \Gamma p e t \varpi:t' \text{ is derivable}
    \end{align*}
  \end{theorem}

  \section{Proofs}

  \subsection{$\texttt{Refine}$ computation}

  Let $\Gamma$, $p$, $e$ and $t$.

    Let's prove that we can reach $\Refine p {e,t} \Gamma=\fixpoint_\Gamma (\RefineStep p {e,t})$ by applying successively the function $\RefineStep p {e,t}$ a finite number of times.

    We will prove that, starting from $\Gamma$, successive applications of $\RefineStep p {e,t}$ stay in a finite set of environments (modulo equivalence).
    For now, let's suppose that $e$ does not contain any \texttt{if then else}. Let's note $\Gamma_i$ the environment after the i-th iteration.

    For any path $\varpi$, we want to find an integer $n$ and a finite set of type $T$ such that $\Gamma_i(\occ e \varpi)$
    is $n$-generated by $T$ for any $i$.

    -----

    \newcommand{\depth}[0]{\mathcal{D}}
    \newcommand{\pathdep}[2]{\texttt{path\_depth}_{#1}(#2)}
    \newcommand{\depof}[2]{\texttt{depthof}_{#1}(#2)}
    \newcommand{\rds}[1]{\texttt{RefineDepthStep}_{#1}}
    \newcommand{\rd}[2]{\texttt{RefineDepth}_{#1}(#2)}

    We call \textit{depth environment} a partial function from variables, constants and lambda abstractions
    to integers. For each depth environment $\depth$ and expression $e$, we define $\depof \depth e$ by:
    \[
      \left\{
        \begin{array}{lcl}
          \depof{\depth}{c} & = & \depth(c) \\
          \depof{\depth}{x} & = & \depth(x) \\
          \depof{\depth}{\lambda^tx.e} & = & \depth(\lambda^tx.e) \\
          \depof{\depth}{(e_1,e_2)} & = & \max {\{\depof{\depth}{e_1},\depof{\depth}{e_2}\}}+1 \\
          \depof{\depth}{e_1 e_2} & = & \depof{\depth}{e_1}-1 \\
          \depof{\depth}{\bpi_i e} & = & \depof{\depth}{e}-1
        \end{array}  
      \right.
    \]

    We also define the depth of a path $\varpi$ by:
    \[
      \left\{
        \begin{array}{lcl}
          \pathdep{\depth,e}{\epsilon} & = & \depof{\depth}{e}\\
          \pathdep{\depth,e}{\varpi.0} & = & \max {\{\pathdep{\depth,e}{\varpi.1},\pathdep{\depth,e}{\varpi}\}}+1\\
          \pathdep{\depth,e}{\varpi.1} & = & \depof{\depth}{\occ e {\varpi.0}}-1\\
          \pathdep{\depth,e}{\varpi.l} & = & \pathdep{\depth,e}{\varpi}-1\\
          \pathdep{\depth,e}{\varpi.r} & = & \pathdep{\depth,e}{\varpi}-1\\
          \pathdep{\depth,e}{\varpi.f} & = & \pathdep{\depth,e}{\varpi}+1\\
          \pathdep{\depth,e}{\varpi.s} & = & \pathdep{\depth,e}{\varpi}+1
        \end{array}  
      \right.
    \]

    \begin{align*}
      &(\rds e (\depth))(e') = 
        \left\{\begin{array}{ll}
          \max \{\pathdep{\depth,e}{\varpi} \alt \varpi \text{ s.t. } \occ e \varpi \equiv e'\} & \text{if e' variable, constant or $\lambda$-abstraction and } \exists \varpi.\ \occ e \varpi \equiv e'\\
          \text{undefined} & \text{otherwise}
        \end{array}\right.\\&\\
      &\rd e \depth=\textsf{lfp}_\depth (\rds e)
    \end{align*}

    -----

%    -----
%
    \newcommand{\struct}[0]{\mathcal{S}}
    \newcommand{\pathstr}[2]{\texttt{path\_struct}_{#1}(#2)}
    \newcommand{\structof}[2]{\texttt{structof}_{#1}(#2)}
    \newcommand{\refinestr}[2]{\texttt{RefineStr}_{#1}(#2)}
    \newcommand{\auxstr}[1]{\texttt{AuxStr}_{#1}}
    \newcommand{\structs}[2]{\texttt{Struct}_{#1}(#2)}
%
%    We call \textit{structural environment} a partial function from variables, constants and lambda abstractions to sets of \textit{structural contexts}.
%    For each structural environment $\struct$ and expression $e$, we define $\structof \struct e$ by:
%    \[
%      \left\{
%        \begin{array}{lcl}
%          \structof{\struct}{c} & = & \struct(c) \\
%          \structof{\struct}{x} & = & \struct(x) \\
%          \structof{\struct}{\lambda^tx.e} & = & \struct(\lambda^tx.e) \\
%          \structof{\struct}{(e_1,e_2)} & = & \bigcup_{s_1\in\structof{\struct}{e_1}}\bigcup_{s_2\in\structof{\struct}{e_2}}  \{ \pair {s_1} {s_2} \} \\
%          \structof{\struct}{e_1 e_2} & = & \bigcup_{\arrow s t\in\structof{\struct}{e_1}} \{ t \} \\
%          \structof{\struct}{\bpi_i e} & = & \bigcup_{\pair {t_1} {t_2}\in\structof{\struct}{e}} \{ t_i \}
%        \end{array}  
%      \right.
%    \]
%
%    We define the \textit{structures} of a path $\varpi$ by:
%    \[
%      \left\{
%        \begin{array}{lcl}
%          \pathstr{\struct,e}{\epsilon} & = & \structof{\struct}{e} \\
%          \pathstr{\struct,e}{\varpi.0} & = & \bigcup_{s\in\pathstr{\struct,e}{\varpi.1}} \bigcup_{t\in\pathstr{\struct,e}{\varpi}} \{\arrow {s} {t}\} \\
%          \pathstr{\struct,e}{\varpi.1} & = & \bigcup_{\arrow s t\in\structof{\struct}{\occ e {\varpi.0}}} \{s\}\\
%          \pathstr{\struct,e}{\varpi.l} & = & \bigcup_{\pair {s_1} {s_2}\in\pathstr{\struct,e}{\varpi}} \{s_1\} \\
%          \pathstr{\struct,e}{\varpi.r} & = & \bigcup_{\pair {s_1} {s_2}\in\pathstr{\struct,e}{\varpi}} \{s_2\} \\
%          \pathstr{\struct,e}{\varpi.f} & = & \bigcup_{s_1\in\pathstr{\struct,e}{\varpi}} \{\pair {{[}]} {s_2}\} \\
%          \pathstr{\struct,e}{\varpi.s} & = & \bigcup_{s_2\in\pathstr{\struct,e}{\varpi}} \{\pair {s_1} {{[}]}\}
%        \end{array}  
%      \right.
%    \]
%
%    \begin{align*}
%      &(\refinestr e \struct)(e') = 
%        \left\{\begin{array}{ll}
%          \text{undefined} & \text{if } e' \text{ not a variable, constant or $\lambda$-abstraction}\\
%          \struct(e') \cup \bigcup_{\{\varpi \alt \occ e \varpi \equiv e'\}} \pathstr{\struct,e}{\varpi} & \text{otherwise, if } e' \in \dom \struct\\
%          \text{undefined} & \text{otherwise}
%        \end{array}\right.\\&\\
%      &\auxstr {\varnothing} (\struct) = \struct\\
%      &\auxstr {\cons {(e,t,p)} \tenv} \struct = \auxstr \tenv (\refinestr e \struct)\\&\\
%      &\structs \tenv \struct=\textsf{lfp}_\struct (\auxstr \tenv)
%    \end{align*}
%
%    Let $\struct_I$ be the structural environment that maps every occurence of variable, constant or $\lambda$-abstraction
%    in $\tenv$ to $[]$.
%
%    $\struct = \structs \tenv {\struct_I}$ is well-defined as $\auxstr \tenv$ is monotonic (and even extensive).
%    Moreover, for any $e\in\dom\struct$, $\struct(e)$ is finite. TODO
%
%    -----

    Let's consider a finite set of types $T$ such that:
    \begin{itemize}
      \item $\forall (e,t,p) \in \tenv$, $t \in T$
      \item $\forall (e,t,p) \in \tenv\ \forall \varpi$, if $\occ e \varpi$ is a lambda abstraction or an annoted $\texttt{ite}$ of type $\ts$, then $\tsrep{\ts} \in T$
      \item $\forall (e,t,p) \in \tenv\ \forall \varpi$, if $\occ e \varpi$ is a constant $c$, then $\basic{c} \in T$
      \item $\forall (e,t,p) \in \tenv\ \forall \varpi$, if $\occ e \varpi \in \dom \Gamma$, then $\tsrep {\Gamma(\occ e \varpi)} \in T$
    \end{itemize}

    Using the previous theorem, let $S$ by a plinth such that $T \subseteq S$. In particular we know that $S$ is finite.

    Let's prove the following invariant. After any number of iteration, the resulting environment $\Gamma'$ is such that:\\
    for any occurence $e'$ in $\tenv$ such that $e' \in \dom {\Gamma'}$, $\tsrep {\Gamma'(e')}$ can be written with a DNF with only atoms
    of the form $\text{ctx}[\vec s]$ with $\vec s$ a vector of elements of $S$ and $\text{ctx}$ an element of $\structof{\struct}{e'}$.
    Note that there is finitely many such DNF.
        
    We prove it by induction on the number of iterations.

    The base case (0 iteration) is trivial.

    For the inductive case, let's take $\Gamma'$ (well-formed) that satifies the induction hypothesis
    and show that $\Gamma'' = \Gaux \tenv {\Gamma'}$ also satisfies the induction hypothesis.

    Let's fix $(e,t,p)$ and $\varpi$.\\
    We need to show that $\Gp p {\Gamma'',e,t} (\varpi)$ has a DNF as described above.    
    We proceed by induction on $\varpi$.

    Before treating the base case and the inductive case, we must show that $\tsrep {\tyof {\occ e \varpi} {\Gamma'}}$
    has the required form.

    It can be easily proven by induction on the derivation (all cases are quite straightfoward given the form of $\structof {} {\_}$).

    Now, the base case of our induction (for $\varpi=\epsilon$) is trivial.

    Here are the inductive cases:
    \begin{description}
      \item[$\varpi.1$] TODO
      \item[$\varpi.0$] TODO
      \item[$\varpi.l$ and $\varpi.r$] TODO
      \item[$\varpi.f$ and $\varpi.s$] TODO
    \end{description}

    It concludes the induction.

    From this result, we can deduce that there is finitely many possible environements that can be produced by the successive applications of $\Gaa \tenv$.
    Indeed, for any relevant expression $e$, there is only finitely many different $\tsrep {\Gamma(e)}$ in the successive environments $\Gamma$ (up to equivalence).
    Using the previous lemma, we deduce that there is finitely many different $\Gamma(e)$ and so finitely many different environments.

    As $\Gaa \tenv$ is reductive, we always reach a fixpoint in a finite number of iterations.
    By construction, this fixpoint is the greatest (as $\Gaa \tenv$ is reductive and monotonic).

    Thus, in order to compute $\fixpoint_\Gamma (\Gaa \tenv)$ we can successively call $\Gaa \tenv$ until we reach a fixpoint.
    In order to know when we have reached a fixpoint, we just have to check whether, for all $(e,t,p) \in \tenv$, for all $e'$ such that
    $\exists \varpi. \occ e \varpi \equiv e'$, we have $\bigwedge_{\{\varpi \alt \occ e \varpi \equiv e'\}} \Gp p {\Gamma,e,t} (\varpi) \in \tsint {\tyof {e'} \Gamma}$.


\end{document}